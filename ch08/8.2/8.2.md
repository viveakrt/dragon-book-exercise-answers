# Exercises for Section 8.2

### 8.2.1

Generate code for the following three-address statements assuming all variables are stored in memory locations.

1. x = 1
2. x = a
3. x = a + 1
4. x = a + b
5. The two statements
    - x = b * c
    - y = a + x

#### answer

    1.  LD R1, #1
        ST x, R1

    2.  LD R1, a
        ST x, R1

    3.  LD R1, a
        ADD R1, R1, #1
        ST x, R1

    4.  LD R1, a
        LD R2, b
        ADD R1, R1, R2
        ST x, R1

    5.  LD R1, b
        LD R2, c
        MUL R1, R1, R2
        LD R3, a
        ADD R3, R3, R1
        ST y, R3

Note: For the fifth question, you can insert the sentences `ST x, R1` and `LD R1, x` after the third line of the generated assembly code. These two sentences are redundant store-load. It’s easy to generate this kind of redundant code using a simple code generation strategy. Slow is slower but it is correct. There is a special optimization to deal with this problem (redundant store-load elimination), so it feels like it is not generated in the answer to this question. Anyway.

### 8.2.2

Generate code for the following three-address statements assuming a and b are arrays whose elements are 4-byte values.

1. The four-statement sequence

        x = a[i]
        y = b[j]
        a[i] = y
        b[j] = x

2. The three-statement sequence

        x = a[i]
        y = b[i]
        z = x * y

3. The three-statement sequence

        x = a[i]
        y = b[x]
        a[i] = y

#### answer

    1.  LD R1, i
        MUL R1, R1, #4
        LD R2, a(R1)
        LD R3, j
        MUL R3, R3, #4
        LD R4, b(R3)
        ST a(R1), R4
        ST b(R3), R2

    2.  LD R1, i
        MUL R1, R1, #4
        LD R2, a(R1)
        LD R1, b(R1)
        MUL R1, R2, R1
        ST z, R1

    3.  LD R1, i
        MUL R1, R1, #4
        LD R2, a(R1)
        MUL R2, R2, #4
        LD R2, b(R2)
        ST a(R1), R2

### 8.2.3

Generate code for the following three-address sequence assuming that p and q are in memory locations:

    y = *q
    q = q + 4
    *p = y
    p = p + 4

#### answer

    LD R1, q
    LD R2, 0(R1)
    ADD R1, R1, #4
    ST q, R1
    LD R1, p
    ST 0(R1), R2
    ADD R1, R1, #4
    ST p, R1

### 8.2.4

Generate code for the following sequence assuming that x, y, and z are in memory locations:

        if x < y goto L1
        z = 0
        goto L2
    L1: z = 1

#### answer

        LD R1, x
        LD R2, y
        SUB R1, R1, R2
        BLTZ R1, L1
        LD R1, #0
        ST z, R1
        BR L2
    L1: LD R1, #1
        ST z, R1

Note: When actually generating the code, the label will be mapped to the specific digital address, but this section has not yet reached that point, just use the label name in the original title and write it casually.

### 8.2.5

Generate code for the following sequence assuming that n is in a memory location:

        s = 0
        i = 0
    L1: if i > n goto L2
        s = s + i
        i = i + 1
        goto L1
    L2:

#### answer

    Long version:

        LD R1, #0
        ST s, R1
        ST i, R1
    L1: LD R1, i
        LD R2, n
        SUB R2, R1, R2
        BGTZ R2, L2
        LD R2, s
        ADD R2, R2, R1
        ST s, R2
        ADD R1, R1, #1
        ST i, R1
        BR L1
    L2:

    Short version:

        LD R2, #0
        LD R1, R2
        LD R3, n
    L1: SUB R4, R1, R3
        BGTZ R4, L2
        ADD R2, R2, R1
        ADD R1, R1, #1
        BR L1
    L2:


Note: Optimization of the short version 1) Eliminate redundant memory-reading 2) Add loop unchanged code 3) Then add register allocation

### 8.2.6

Determine the costs of the following instruction sequences:

    1.  LD R0, y
        LD R1, z
        ADD R0, R0, R1
        ST x, R0

    2.  LD R0, i
        MUL R0, R0, 8
        LD R1, a(R0)
        ST b, R1

    3.  LD R0, c
        LD R1, i
        MUL R1, R1, 8
        ST a(R1),R0

    4.  LD R0, p
        LD R1, 0(R0)
        ST x, R1

    5.  LD R0, p
        LD R1, x
        ST 0(R0), R1

    6.  LD R0, x
        LD R1, y
        SUB R0, R0, R1
        BLTZ *R3, R0

#### answer

1. 2 + 2 + 1 + 2 = 7
2. 2 + 2 + 2 + 2 = 8
3. 2 + 2 + 2 + 2 = 8
4. 2 + 2 + 2 = 6
5. 2 + 2 + 2 = 6
6. 2 + 2 + 1 + 1 = 6

Note: The instruction set used in this book does not clearly define the details of all instructions, but it seems that the use of variable names to specify memory addresses actually implies the assumption that these variables are statically allocated, which means that the instructions are actually generated. These variable names will be replaced with their corresponding numeric address constants, and the address is stored in an extra word after the instruction, which is an additional unit of overhead.

---

### Note

1. Obviously, the content of this section is written very casually. It is recommended that all numeric constants should be prefixed with #, except in the address. For example, `LD R1, #1` and ʻADD R1, R1, #1`.

2. In this book, Ri represents the i-th register.

    1. In the process of translating into assembly code, is it possible to specify the value of i at will (such as R3, R4, R1000) or is there some restriction?

        Answer: For now, please feel free. When the number of registers is limited later, consider the limited situation.

    2. In addition, if the R1 shown in the code is not used in the following code, can the new value be loaded into R1? If so, how do you know that the previous R1 is no longer needed?

        Answer: It can be overwritten. As for how to know that the previous value is dead, it depends on the def-use chain. This is an important issue for optimization. For example, the live variable in section 9.2.5 is related to this.

3. b = a[i] corresponding assembly code：

    ```
    LD R1, i
    MUL R1, R1, 8
    LD R2, a(R1)
    ...
    ```

Among them, why does not need to load to the register first?

    Answer: There is an implicit assumption here: variables are statically allocated and stored. The situation will change when the variable is not static later.
